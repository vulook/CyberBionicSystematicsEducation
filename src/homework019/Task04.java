package homework019;

/**
 * FileName: Task04
 * Author:   Andriy Vulook
 * Date:     10.03.2023 19:49
 * Description: Go to the Oracle website
 */

public class Task04 {

/*
Виняток — це подія, що відбувається під час виконання програми, яка порушує нормальний хід програмних інструкцій.
Коли в методі виникає помилка, метод створює об’єкт і передає його системі виконання. Об’єкт, який називається об’єкт винятку , містить
інформацію про помилку, включаючи її тип і стан програми, коли помилка сталася. Створення об'єкта винятку та передача його системі виконання
називається створенням винятку .

Після того, як метод викидає виняток, система виконання намагається знайти щось для його обробки. Набір можливих «щось» для обробки виключення —
це впорядкований список методів, які були викликані, щоб отримати доступ до методу, де сталася помилка. Список методів відомий як стек викликів.
Система середовища виконання шукає в стеку викликів метод, який містить блок коду, який може обробити виняток. Цей блок коду називається
обробником винятків . Пошук починається з методу, в якому сталася помилка, і продовжується через стек викликів у зворотному порядку,
в якому були викликані методи. Коли відповідний обробник знайдено, система виконання передає виняток обробнику.
Обробник винятків вважається прийнятним, якщо тип створеного об’єкта винятку відповідає типу, який може обробити обробник.

Мова програмування Java не вимагає методів для перехоплення або визначення неперевірених винятків ( RuntimeException, Error, та їхніх підкласів),
у програмістів може виникнути спокуса написати код, який викидає лише неперевірені винятки, або зробити так, щоб усі їхні підкласи
винятків успадковували від RuntimeException. Обидва ці ярлики дозволяють програмістам писати код, не турбуючись про помилки компілятора та
не турбуючись про вказівку чи перелов будь-яких винятків. Незважаючи на те, що це може здатися програмісту зручним,
це обходить мету вимоги catch або specify може спричинити проблеми для інших, які використовують ваші класи.

Програма може перехоплювати винятки, використовуючи комбінацію блоків try, catch, і finally.

Блок try визначає блок коду, в якому може статися виняток.
Блок catch визначає блок коду, відомий як обробник винятків, який може обробляти певний тип винятків.
Блок finally визначає блок коду, який гарантовано буде виконуватися, і є правильним місцем для закриття файлів,
відновлення ресурсів та іншого очищення після коду, укладеного в блоці try.
Оператор try повинен містити принаймні один catchблок або finallyблок і може мати кілька catchблоків.

Клас об’єкта винятку вказує на тип створеного винятку.
Об’єкт винятку може містити додаткову інформацію про помилку, включаючи повідомлення про помилку.
За допомогою ланцюжка винятків виняток може вказувати на виняток, який його спричинив, який, у свою чергу, може вказувати на виняток,
який його спричинив , і так далі.

Чому розробники вирішили змусити метод вказувати всі неперехоплені перевірені винятки, які можуть бути викинуті в його області?
Будь-який Exception, який може бути створений методом, є частиною загальнодоступного інтерфейсу програмування методу.
Ті, хто викликає метод, повинні знати про винятки, які може викликати метод, щоб вони могли вирішити, що з ними робити.
Ці винятки є такою ж частиною інтерфейсу програмування цього методу, як і його параметри та return значення.

Винятки надають засоби для відокремлення деталей того, що робити, коли відбувається щось незвичайне, від основної логіки програми.
У традиційному програмуванні виявлення помилок, звітування та обробка часто призводять до заплутаного спагетті-коду.
Другою перевагою винятків є можливість поширювати повідомлення про помилки до стека викликів методів.

Оскільки всі винятки, створені в програмі, є об’єктами, групування або категоризація винятків є природним результатом ієрархії класів.
Прикладом групи пов’язаних класів винятків у платформі Java є класи, визначені в java.io— IOException та його нащадки.
IOExceptionє найбільш загальним і представляє будь-який тип помилки, яка може виникнути під час виконання введення-виведення.
Його нащадки представляють більш конкретні помилки.

Клас Exception знаходиться близько до вершини Throwable ієрархії класів. Таким чином, цей обробник буде перехоплювати багато інших винятків
на додаток до тих, які призначений для перехоплення. Ви можете обробляти винятки таким чином, якщо все, що ви хочете, щоб ваша програма зробила,
наприклад, це вивести повідомлення про помилку для користувача, а потім вийти.
Однак у більшості ситуацій ви хочете, щоб обробники винятків були якомога більш конкретними. Причина полягає в тому, що перше,
що повинен зробити обробник, це визначити тип виняткової ситуації, перш ніж він зможе вибрати найкращу стратегію відновлення.
По суті, не вловлюючи конкретні помилки, обробник повинен врахувати будь-яку можливість.
Занадто загальні обробники винятків можуть зробити код більш схильним до помилок, перехоплюючи та обробляючи винятки,
які не були передбачені програмістом і для яких обробник не був призначений.

Три компоненти обробника винятків — блоки try, catch, і finally — для написання обробника винятків.
Потім try-пояснюється оператор with-resources, представлений у Java SE 7.
Інструкція try-with-resources особливо підходить для ситуацій, у яких використовуються Closeable ресурси, наприклад потоки.

Оператор try-with-resources - це try оператор, який оголошує один або більше ресурсів. Ресурс - це об'єкт,
який необхідно закрити після завершення роботи з ним програми . Оператор try-with-resources забезпечує закриття кожного ресурсу в кінці оператора.
Будь-який об’єкт, який реалізує java.lang.AutoCloseable, який включає всі об’єкти, які реалізують java.io.Closeable, може бути використаний як ресурс.

У наступному прикладі читається перший рядок із файлу. Він використовує екземпляр FileReaderі BufferedReader для читання даних із файлу.
FileReader і BufferedReader є ресурсами, які необхідно закрити після завершення роботи програми:

	static String readFirstLineFromFile(String path) генерує IOException {
	     try (FileReader fr = new FileReader(path);
	         BufferedReader br = новий BufferedReader(fr)) {
	        return br.readLine();
	    }
	}
У цьому прикладі ресурси, оголошені в try операторі -with-resources, є a FileReaderі a BufferedReader.
Оголошення цих ресурсів відображаються в круглих дужках відразу після tryключового слова.
Класи FileReader і BufferedReader в Java SE 7 і пізніших реалізують інтерфейс java.lang.AutoCloseable.
Оскільки екземпляри FileReaderand BufferedReaderоголошено в try інструкції -with-resource, вони будуть закриті незалежно від того,
чи try завершується інструкція нормально чи раптово (в результаті того, що метод BufferedReader.readLine видає IOException).

try Оператор -with-resources може мати блоки catch та finally блоки, як і звичайний try оператор. У try операторі -with-resources
будь -який catch або finally блок запускається після того, як оголошені ресурси були закриті.

 */

}
