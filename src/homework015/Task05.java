package homework015;

/**
 * FileName: Task05
 * Author:   Andriy Vulook
 * Date:     06.03.2023 21:11
 * Description: Polymorphism and Declaring Member Variables and  Inheritance
 */

public class Task05 {

/*
  Підкласи класу можуть визначати свою власну унікальну поведінку і водночас використовувати деякі ті самі функції,
  що й батьківський клас. *
  Поліморфізм можна продемонструвати незначною модифікацією класу Bicycle. Наприклад, printDescription до класу можна
  додати метод, який відображає всі дані, які наразі зберігаються в екземплярі.

  Щоб продемонструвати поліморфні функції в мові Java, розширте Bicycle клас за допомогою MountainBike і RoadBike class.
  Для MountainBike, додайте поле для suspension, яке є String значенням і вказує, чи має велосипед передній амортизатор,
  - Front. Або велосипед має передній і задній амортизатори - Dual.
  Підсумовуючи, існує три класи: Bicycle, MountainBike, і RoadBike.
  Два підкласи замінюють printDescriptionметод і друкують унікальну інформацію.
  Віртуальна машина Java (JVM) викликає відповідний метод для об’єкта, на який посилається кожна змінна.
  Він не викликає метод, який визначається типом змінної. Така поведінка називається віртуальним викликом методу та
  демонструє аспект важливих функцій поліморфізму в мові Java.

  Є кілька типів змінних:
  Змінні-члени в класі — вони називаються полями .
  Змінні в методі або блоці коду — вони називаються локальними змінними .
  Змінні в оголошеннях методів — вони називаються параметрами .

  public модифікатор — поле доступне з усіх класів.
  private модифікатор — поле доступне тільки в межах власного класу.

  Усі змінні повинні мати тип. Ви можете використовувати примітивні типи, такі як int, float, boolean тощо.
  Або ви можете використовувати типові посилання, такі як рядки, масиви або об’єкти.
  Для імен методів і класів використовуються ті самі правила іменування, за винятком того, що
  => перша літера назви класу має бути великою, і
  => перше (або єдине) слово в назві методу має бути дієсловом.

  Клас, який є похідним від іншого класу, називається підкласом (також похідним класом, розширеним класом або
  дочірнім класом ). Клас, від якого походить підклас, називається суперкласом (також базовим класом або
  батьківським класом ).

  За винятком Object, який не має суперкласу, кожен клас має один і тільки один прямий суперклас (єдине успадкування).
  За відсутності будь-якого іншого явного суперкласу кожен клас неявно є підкласом Object.
  Класи можуть бути похідними від класів, які є похідними від класів, і так далі, і, зрештою,
  похідними від найвищого класу, Object. Кажуть, що такий клас походить від усіх класів у ланцюжку успадкування,
  що тягнеться до Object.

  Ідея успадкування проста, але потужна: якщо ви хочете створити новий клас і вже є клас, який містить частину
  потрібного вам коду, ви можете отримати свій новий клас із існуючого класу. Роблячи це, ви можете повторно
  використовувати поля та методи існуючого класу без необхідності писати (і налагоджувати!) їх самостійно.
  Підклас успадковує всі члени (поля, методи та вкладені класи) від свого суперкласу.
  Конструктори не є членами, тому вони не успадковуються підкласами, але конструктор суперкласу можна викликати
  з підкласу.

  Підклас успадковує всі загальнодоступні та захищені члени свого батьківського класу, незалежно від того,
  у якому пакеті знаходиться підклас. Якщо підклас знаходиться в тому самому пакеті, що й його батьківський,
  він також успадковує приватні члени батьківського пакету. Ви можете використовувати успадковані члени як є,
  замінити їх, приховати або доповнити новими членами:

  => Успадковані поля можна використовувати безпосередньо, як і будь-які інші поля.
  => Ви можете оголосити поле в підкласі з тим же ім’ям, що й поле в суперкласі, таким чином приховавши його
  (не рекомендовано).
  => Ви можете оголосити нові поля в підкласі, яких немає в суперкласі.
  => Успадковані методи можна використовувати безпосередньо як вони є.
  => Ви можете написати новий метод екземпляра в підкласі, який має таку саму сигнатуру, як і в суперкласі,
  таким чином замінивши його.
  => Ви можете написати новий статичний метод у підкласі, який має ту саму сигнатуру, що й у суперкласі,
  таким чином приховуючи його.
  => Ви можете оголосити нові методи в підкласі, яких немає в суперкласі.
  => Ви можете написати конструктор підкласу, який викликає конструктор суперкласу, неявно або за допомогою
  ключового слова super.

  Підклас не успадковує private членів свого батьківського класу. Однак, якщо суперклас має загальнодоступні
  або захищені методи доступу до своїх приватних полів, вони також можуть використовуватися підкласом.
  Вкладений клас має доступ до всіх приватних членів класу, що його охоплює — як полів, так і методів.
  Тому публічний або захищений вкладений клас, успадкований підкласом, має непрямий доступ до всіх
  приватних членів суперкласу.

 Upcasting — це приведення типу дочірнього об’єкта до батьківського . Переведення може бути виконане неявно.
 Upcasting дає нам гнучкість доступу до членів батьківського класу, але за допомогою цієї функції неможливо отримати
 доступ до всіх членів дочірнього класу. Замість усіх членів ми можемо отримати доступ до певних членів дочірнього класу.
 Наприклад, ми можемо отримати доступ до перевизначених методів.
 Зниження типу: аналогічно, зведення означає приведення типів батьківського об’єкта до дочірнього об’єкта .
 Зниження не може бути неявним.

  Приведення показує використання об’єкта одного типу замість іншого типу серед об’єктів, дозволених
  успадкуванням і реалізаціями. Наприклад, якщо ми пишемо:

  Object obj = new MountainBike();

  тоді obj є як Object так і MountainBike (до того часу, поки obj не буде призначено інший об’єкт, який не є MountainBike.
  Це називається неявним приведенням.
  Якщо, навпаки, ми пишемо:   MountainBike myBike = obj;

  Ми отримаємо помилку під час компіляції, оскільки obj компілятор не знає, що це MountainBike.
  Однак ми можемо сказати компілятору, що обіцяємо призначити a MountainBike шляхом obj явного приведення:

  MountainBike myBike = (MountainBike) obj;
  Це приведення вставляє перевірку часу виконання, якій obj присвоєно MountainBike, щоб компілятор міг
  безпечно вважати, що obj - це MountainBike. Якщо obj не MountainBike під час виконання, буде створено виняток.

 */


}
